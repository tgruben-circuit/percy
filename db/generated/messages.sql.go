// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: messages.sql

package generated

import (
	"context"
)

const countMessagesByType = `-- name: CountMessagesByType :one
SELECT COUNT(*) FROM messages
WHERE conversation_id = ? AND type = ?
`

type CountMessagesByTypeParams struct {
	ConversationID string `json:"conversation_id"`
	Type           string `json:"type"`
}

func (q *Queries) CountMessagesByType(ctx context.Context, arg CountMessagesByTypeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMessagesByType, arg.ConversationID, arg.Type)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMessagesInConversation = `-- name: CountMessagesInConversation :one
SELECT COUNT(*) FROM messages
WHERE conversation_id = ?
`

func (q *Queries) CountMessagesInConversation(ctx context.Context, conversationID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMessagesInConversation, conversationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (message_id, conversation_id, sequence_id, type, llm_data, user_data, usage_data, display_data, excluded_from_context)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING message_id, conversation_id, sequence_id, type, llm_data, user_data, usage_data, created_at, display_data, excluded_from_context
`

type CreateMessageParams struct {
	MessageID           string  `json:"message_id"`
	ConversationID      string  `json:"conversation_id"`
	SequenceID          int64   `json:"sequence_id"`
	Type                string  `json:"type"`
	LlmData             *string `json:"llm_data"`
	UserData            *string `json:"user_data"`
	UsageData           *string `json:"usage_data"`
	DisplayData         *string `json:"display_data"`
	ExcludedFromContext bool    `json:"excluded_from_context"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createMessage,
		arg.MessageID,
		arg.ConversationID,
		arg.SequenceID,
		arg.Type,
		arg.LlmData,
		arg.UserData,
		arg.UsageData,
		arg.DisplayData,
		arg.ExcludedFromContext,
	)
	var i Message
	err := row.Scan(
		&i.MessageID,
		&i.ConversationID,
		&i.SequenceID,
		&i.Type,
		&i.LlmData,
		&i.UserData,
		&i.UsageData,
		&i.CreatedAt,
		&i.DisplayData,
		&i.ExcludedFromContext,
	)
	return i, err
}

const deleteConversationMessages = `-- name: DeleteConversationMessages :exec
DELETE FROM messages
WHERE conversation_id = ?
`

func (q *Queries) DeleteConversationMessages(ctx context.Context, conversationID string) error {
	_, err := q.db.ExecContext(ctx, deleteConversationMessages, conversationID)
	return err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages
WHERE message_id = ?
`

func (q *Queries) DeleteMessage(ctx context.Context, messageID string) error {
	_, err := q.db.ExecContext(ctx, deleteMessage, messageID)
	return err
}

const deleteMessagesAfterSequence = `-- name: DeleteMessagesAfterSequence :exec
DELETE FROM messages
WHERE conversation_id = ? AND sequence_id > ?
`

type DeleteMessagesAfterSequenceParams struct {
	ConversationID string `json:"conversation_id"`
	SequenceID     int64  `json:"sequence_id"`
}

func (q *Queries) DeleteMessagesAfterSequence(ctx context.Context, arg DeleteMessagesAfterSequenceParams) error {
	_, err := q.db.ExecContext(ctx, deleteMessagesAfterSequence, arg.ConversationID, arg.SequenceID)
	return err
}

const deleteMessagesFromSequence = `-- name: DeleteMessagesFromSequence :exec
DELETE FROM messages
WHERE conversation_id = ? AND sequence_id >= ?
`

type DeleteMessagesFromSequenceParams struct {
	ConversationID string `json:"conversation_id"`
	SequenceID     int64  `json:"sequence_id"`
}

func (q *Queries) DeleteMessagesFromSequence(ctx context.Context, arg DeleteMessagesFromSequenceParams) error {
	_, err := q.db.ExecContext(ctx, deleteMessagesFromSequence, arg.ConversationID, arg.SequenceID)
	return err
}

const getLatestMessage = `-- name: GetLatestMessage :one
SELECT message_id, conversation_id, sequence_id, type, llm_data, user_data, usage_data, created_at, display_data, excluded_from_context FROM messages
WHERE conversation_id = ?
ORDER BY sequence_id DESC
LIMIT 1
`

func (q *Queries) GetLatestMessage(ctx context.Context, conversationID string) (Message, error) {
	row := q.db.QueryRowContext(ctx, getLatestMessage, conversationID)
	var i Message
	err := row.Scan(
		&i.MessageID,
		&i.ConversationID,
		&i.SequenceID,
		&i.Type,
		&i.LlmData,
		&i.UserData,
		&i.UsageData,
		&i.CreatedAt,
		&i.DisplayData,
		&i.ExcludedFromContext,
	)
	return i, err
}

const getMessage = `-- name: GetMessage :one
SELECT message_id, conversation_id, sequence_id, type, llm_data, user_data, usage_data, created_at, display_data, excluded_from_context FROM messages
WHERE message_id = ?
`

func (q *Queries) GetMessage(ctx context.Context, messageID string) (Message, error) {
	row := q.db.QueryRowContext(ctx, getMessage, messageID)
	var i Message
	err := row.Scan(
		&i.MessageID,
		&i.ConversationID,
		&i.SequenceID,
		&i.Type,
		&i.LlmData,
		&i.UserData,
		&i.UsageData,
		&i.CreatedAt,
		&i.DisplayData,
		&i.ExcludedFromContext,
	)
	return i, err
}

const getNextSequenceID = `-- name: GetNextSequenceID :one
SELECT COALESCE(MAX(sequence_id), 0) + 1 
FROM messages 
WHERE conversation_id = ?
`

func (q *Queries) GetNextSequenceID(ctx context.Context, conversationID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNextSequenceID, conversationID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const listMessages = `-- name: ListMessages :many
SELECT message_id, conversation_id, sequence_id, type, llm_data, user_data, usage_data, created_at, display_data, excluded_from_context FROM messages
WHERE conversation_id = ?
ORDER BY sequence_id ASC
`

func (q *Queries) ListMessages(ctx context.Context, conversationID string) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, listMessages, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.MessageID,
			&i.ConversationID,
			&i.SequenceID,
			&i.Type,
			&i.LlmData,
			&i.UserData,
			&i.UsageData,
			&i.CreatedAt,
			&i.DisplayData,
			&i.ExcludedFromContext,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesByType = `-- name: ListMessagesByType :many
SELECT message_id, conversation_id, sequence_id, type, llm_data, user_data, usage_data, created_at, display_data, excluded_from_context FROM messages
WHERE conversation_id = ? AND type = ?
ORDER BY sequence_id ASC
`

type ListMessagesByTypeParams struct {
	ConversationID string `json:"conversation_id"`
	Type           string `json:"type"`
}

func (q *Queries) ListMessagesByType(ctx context.Context, arg ListMessagesByTypeParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, listMessagesByType, arg.ConversationID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.MessageID,
			&i.ConversationID,
			&i.SequenceID,
			&i.Type,
			&i.LlmData,
			&i.UserData,
			&i.UsageData,
			&i.CreatedAt,
			&i.DisplayData,
			&i.ExcludedFromContext,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesForContext = `-- name: ListMessagesForContext :many
SELECT message_id, conversation_id, sequence_id, type, llm_data, user_data, usage_data, created_at, display_data, excluded_from_context FROM messages
WHERE conversation_id = ? AND excluded_from_context = FALSE
ORDER BY sequence_id ASC
`

func (q *Queries) ListMessagesForContext(ctx context.Context, conversationID string) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, listMessagesForContext, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.MessageID,
			&i.ConversationID,
			&i.SequenceID,
			&i.Type,
			&i.LlmData,
			&i.UserData,
			&i.UsageData,
			&i.CreatedAt,
			&i.DisplayData,
			&i.ExcludedFromContext,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesPaginated = `-- name: ListMessagesPaginated :many
SELECT message_id, conversation_id, sequence_id, type, llm_data, user_data, usage_data, created_at, display_data, excluded_from_context FROM messages
WHERE conversation_id = ?
ORDER BY sequence_id ASC
LIMIT ? OFFSET ?
`

type ListMessagesPaginatedParams struct {
	ConversationID string `json:"conversation_id"`
	Limit          int64  `json:"limit"`
	Offset         int64  `json:"offset"`
}

func (q *Queries) ListMessagesPaginated(ctx context.Context, arg ListMessagesPaginatedParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, listMessagesPaginated, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.MessageID,
			&i.ConversationID,
			&i.SequenceID,
			&i.Type,
			&i.LlmData,
			&i.UserData,
			&i.UsageData,
			&i.CreatedAt,
			&i.DisplayData,
			&i.ExcludedFromContext,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesSince = `-- name: ListMessagesSince :many
SELECT message_id, conversation_id, sequence_id, type, llm_data, user_data, usage_data, created_at, display_data, excluded_from_context FROM messages
WHERE conversation_id = ? AND sequence_id > ?
ORDER BY sequence_id ASC
`

type ListMessagesSinceParams struct {
	ConversationID string `json:"conversation_id"`
	SequenceID     int64  `json:"sequence_id"`
}

func (q *Queries) ListMessagesSince(ctx context.Context, arg ListMessagesSinceParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, listMessagesSince, arg.ConversationID, arg.SequenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.MessageID,
			&i.ConversationID,
			&i.SequenceID,
			&i.Type,
			&i.LlmData,
			&i.UserData,
			&i.UsageData,
			&i.CreatedAt,
			&i.DisplayData,
			&i.ExcludedFromContext,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesUpToSequence = `-- name: ListMessagesUpToSequence :many
SELECT message_id, conversation_id, sequence_id, type, llm_data, user_data, usage_data, created_at, display_data, excluded_from_context FROM messages
WHERE conversation_id = ? AND sequence_id <= ?
ORDER BY sequence_id ASC
`

type ListMessagesUpToSequenceParams struct {
	ConversationID string `json:"conversation_id"`
	SequenceID     int64  `json:"sequence_id"`
}

func (q *Queries) ListMessagesUpToSequence(ctx context.Context, arg ListMessagesUpToSequenceParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, listMessagesUpToSequence, arg.ConversationID, arg.SequenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.MessageID,
			&i.ConversationID,
			&i.SequenceID,
			&i.Type,
			&i.LlmData,
			&i.UserData,
			&i.UsageData,
			&i.CreatedAt,
			&i.DisplayData,
			&i.ExcludedFromContext,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessageUserData = `-- name: UpdateMessageUserData :exec
UPDATE messages SET user_data = ? WHERE message_id = ?
`

type UpdateMessageUserDataParams struct {
	UserData  *string `json:"user_data"`
	MessageID string  `json:"message_id"`
}

func (q *Queries) UpdateMessageUserData(ctx context.Context, arg UpdateMessageUserDataParams) error {
	_, err := q.db.ExecContext(ctx, updateMessageUserData, arg.UserData, arg.MessageID)
	return err
}
