// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: usage.sql

package generated

import (
	"context"
	"time"
)

const getUsageByConversation = `-- name: GetUsageByConversation :many
SELECT
  c.conversation_id,
  c.slug,
  json_extract(m.usage_data, '$.model') as usage_model,
  COUNT(*) as message_count,
  COALESCE(SUM(json_extract(m.usage_data, '$.input_tokens')), 0) as total_input_tokens,
  COALESCE(SUM(json_extract(m.usage_data, '$.output_tokens')), 0) as total_output_tokens,
  COALESCE(SUM(json_extract(m.usage_data, '$.cache_read_input_tokens')), 0) as total_cache_read_tokens,
  COALESCE(SUM(json_extract(m.usage_data, '$.cache_creation_input_tokens')), 0) as total_cache_write_tokens,
  COALESCE(SUM(json_extract(m.usage_data, '$.cost_usd')), 0) as total_cost_usd
FROM messages m
JOIN conversations c ON m.conversation_id = c.conversation_id
WHERE m.type = 'agent'
  AND m.usage_data IS NOT NULL
  AND m.created_at >= ?
GROUP BY c.conversation_id
ORDER BY total_cost_usd DESC
`

type GetUsageByConversationRow struct {
	ConversationID        string      `json:"conversation_id"`
	Slug                  *string     `json:"slug"`
	UsageModel            interface{} `json:"usage_model"`
	MessageCount          int64       `json:"message_count"`
	TotalInputTokens      interface{} `json:"total_input_tokens"`
	TotalOutputTokens     interface{} `json:"total_output_tokens"`
	TotalCacheReadTokens  interface{} `json:"total_cache_read_tokens"`
	TotalCacheWriteTokens interface{} `json:"total_cache_write_tokens"`
	TotalCostUsd          interface{} `json:"total_cost_usd"`
}

// Aggregates usage per conversation for a date range.
func (q *Queries) GetUsageByConversation(ctx context.Context, createdAt time.Time) ([]GetUsageByConversationRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsageByConversation, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsageByConversationRow{}
	for rows.Next() {
		var i GetUsageByConversationRow
		if err := rows.Scan(
			&i.ConversationID,
			&i.Slug,
			&i.UsageModel,
			&i.MessageCount,
			&i.TotalInputTokens,
			&i.TotalOutputTokens,
			&i.TotalCacheReadTokens,
			&i.TotalCacheWriteTokens,
			&i.TotalCostUsd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageByDate = `-- name: GetUsageByDate :many
SELECT
  date(m.created_at) as date,
  json_extract(m.usage_data, '$.model') as usage_model,
  COUNT(*) as message_count,
  COALESCE(SUM(json_extract(m.usage_data, '$.input_tokens')), 0) as total_input_tokens,
  COALESCE(SUM(json_extract(m.usage_data, '$.output_tokens')), 0) as total_output_tokens,
  COALESCE(SUM(json_extract(m.usage_data, '$.cache_read_input_tokens')), 0) as total_cache_read_tokens,
  COALESCE(SUM(json_extract(m.usage_data, '$.cache_creation_input_tokens')), 0) as total_cache_write_tokens,
  COALESCE(SUM(json_extract(m.usage_data, '$.cost_usd')), 0) as total_cost_usd
FROM messages m
JOIN conversations c ON m.conversation_id = c.conversation_id
WHERE m.type = 'agent'
  AND m.usage_data IS NOT NULL
  AND m.created_at >= ?
GROUP BY date(m.created_at), json_extract(m.usage_data, '$.model')
ORDER BY date(m.created_at) DESC
`

type GetUsageByDateRow struct {
	Date                  interface{} `json:"date"`
	UsageModel            interface{} `json:"usage_model"`
	MessageCount          int64       `json:"message_count"`
	TotalInputTokens      interface{} `json:"total_input_tokens"`
	TotalOutputTokens     interface{} `json:"total_output_tokens"`
	TotalCacheReadTokens  interface{} `json:"total_cache_read_tokens"`
	TotalCacheWriteTokens interface{} `json:"total_cache_write_tokens"`
	TotalCostUsd          interface{} `json:"total_cost_usd"`
}

// Aggregates usage data from agent messages.
// Returns one row per (date, model) pair.
func (q *Queries) GetUsageByDate(ctx context.Context, createdAt time.Time) ([]GetUsageByDateRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsageByDate, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsageByDateRow{}
	for rows.Next() {
		var i GetUsageByDateRow
		if err := rows.Scan(
			&i.Date,
			&i.UsageModel,
			&i.MessageCount,
			&i.TotalInputTokens,
			&i.TotalOutputTokens,
			&i.TotalCacheReadTokens,
			&i.TotalCacheWriteTokens,
			&i.TotalCostUsd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
